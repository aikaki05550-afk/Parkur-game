<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>3D Parkour: Girl & Boy</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; }
        #menu {
            position: absolute; inset: 0; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            background: radial-gradient(circle, #2c3e50, #000); color: white; z-index: 100;
        }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            font-size: 26px; display: none; text-shadow: 2px 2px #000; font-weight: bold;
        }
        .box { background: rgba(255,255,255,0.1); padding: 30px; border-radius: 20px; text-align: center; border: 1px solid rgba(255,255,255,0.2); }
        button {
            padding: 15px 60px; font-size: 22px; cursor: pointer; margin-top: 20px;
            background: #27ae60; border: none; color: white; border-radius: 50px;
            transition: 0.3s; box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        button:hover { background: #2ecc71; transform: scale(1.05); }
        select { padding: 12px; margin: 10px; font-size: 18px; border-radius: 8px; width: 250px; cursor: pointer; }
        label { font-size: 18px; display: block; margin-top: 15px; opacity: 0.9; }
    </style>
</head>
<body>

<div id="menu">
    <div class="box">
        <h1>BLOCK PARKOUR 3D</h1>
        <label>–í—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:</label>
        <select id="gender">
            <option value="girl">üëß –î–µ–≤–æ—á–∫–∞ (–î–ª–∏–Ω–Ω—ã–µ –≤–æ–ª–æ—Å—ã)</option>
            <option value="boy">üë¶ –ú–∞–ª—å—á–∏–∫ (–ö–æ—Ä–æ—Ç–∫–∞—è —Å—Ç—Ä–∏–∂–∫–∞)</option>
        </select>
        <label>–¶–≤–µ—Ç –æ–¥–µ–∂–¥—ã:</label>
        <select id="skin">
            <option value="0xff69b4">–ù–µ–∂–Ω–æ-—Ä–æ–∑–æ–≤—ã–π</option>
            <option value="0x3498db">–Ø—Ä–∫–æ-—Å–∏–Ω–∏–π</option>
            <option value="0x9b59b6">–§–∏–æ–ª–µ—Ç–æ–≤—ã–π</option>
            <option value="0xe67e22">–û—Ä–∞–Ω–∂–µ–≤—ã–π</option>
        </select>
        <button id="startBtn">–ü–û–ï–•–ê–õ–ò!</button>
    </div>
</div>

<div id="ui">–£–†–û–í–ï–ù–¨: <span id="lvl">1</span></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>

<script>
let scene, camera, renderer, player, headAnchor;
let keys = {};
let platforms = [];
let currentLevel = 1;
let velocity = new THREE.Vector3();
let yaw = 0, pitch = 0;

document.getElementById('startBtn').onclick = function() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    init();
};

function createModel(gender, color) {
    const group = new THREE.Group();
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
    const clothesMat = new THREE.MeshStandardMaterial({ color: color });
    const hairMat = new THREE.MeshStandardMaterial({ color: gender === 'girl' ? 0x4b3020 : 0x222222 });

    // –¢–µ–ª–æ
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.9, 0.3), clothesMat);
    body.position.y = 0.45;
    group.add(body);

    // –ù–æ–≥–∏
    const legG = new THREE.BoxGeometry(0.25, 0.6, 0.25);
    const legL = new THREE.Mesh(legG, new THREE.MeshStandardMaterial({ color: 0x333333 }));
    legL.position.set(-0.15, -0.2, 0);
    group.add(legL);
    const legR = new THREE.Mesh(legG, new THREE.MeshStandardMaterial({ color: 0x333333 }));
    legR.position.set(0.15, -0.2, 0);
    group.add(legR);

    // –ì–æ–ª–æ–≤–∞ (–Ø–∫–æ—Ä—å –¥–ª—è –∫–∞–º–µ—Ä—ã)
    headAnchor = new THREE.Group();
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.45, 0.45), skinMat);
    headAnchor.add(head);

    // –í–æ–ª–æ—Å—ã
    if (gender === 'girl') {
        const hairTop = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.5), hairMat);
        hairTop.position.y = 0.25;
        headAnchor.add(hairTop);
        const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.2), hairMat);
        hairBack.position.set(0, -0.1, -0.25);
        headAnchor.add(hairBack);
    } else {
        const hairCap = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.25, 0.5), hairMat);
        hairCap.position.y = 0.15;
        headAnchor.add(hairCap);
    }

    headAnchor.position.y = 1.15;
    group.add(headAnchor);
    return group;
}

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 100);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8);
    sun.position.set(10, 20, 10);
    sun.castShadow = true;
    scene.add(sun);

    const gender = document.getElementById('gender').value;
    const color = parseInt(document.getElementById('skin').value, 16);
    player = createModel(gender, color);
    scene.add(player);
    player.position.set(0, 5, 0);

    buildLevel(currentLevel);

    window.onkeydown = (e) => keys[e.code] = true;
    window.onkeyup = (e) => keys[e.code] = false;

    document.body.onclick = () => document.body.requestPointerLock();
    document.onmousemove = (e) => {
        if (document.pointerLockElement) {
            yaw -= e.movementX * 0.003;
            pitch -= e.movementY * 0.003;
            pitch = Math.max(-1.4, Math.min(1.4, pitch)); // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑
        }
    };

    animate();
}

function buildLevel(lvl) {
    platforms.forEach(p => scene.remove(p));
    platforms = [];
    document.getElementById('lvl').innerText = lvl;

    // –°—Ç–∞—Ä—Ç
    const start = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 8), new THREE.MeshStandardMaterial({ color: 0x27ae60 }));
    start.position.set(0, -0.5, 0);
    scene.add(start);
    platforms.push(start);

    for (let i = 1; i <= 10 + lvl; i++) {
        const finish = (i === 10 + lvl);
        const b = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.5, 2.5),
            new THREE.MeshStandardMaterial({ color: finish ? 0xf1c40f : 0xffffff })
        );
        b.position.set((Math.random()-0.5)*8, i*0.5, -i*4.5);
        scene.add(b);
        platforms.push(b);
    }
}

function animate() {
    requestAnimationFrame(animate);

    const speed = keys['ShiftLeft'] ? 0.2 : 0.12;
    if (keys['KeyW']) player.translateZ(-speed);
    if (keys['KeyS']) player.translateZ(speed);
    if (keys['KeyA']) player.translateX(-speed);
    if (keys['KeyD']) player.translateX(speed);

    player.rotation.y = yaw;
    headAnchor.rotation.x = pitch; // –í—Ä–∞—â–∞–µ–º –≥–æ–ª–æ–≤—É –º–æ–¥–µ–ª–∏

    velocity.y -= 0.012;
    player.position.y += velocity.y;

    let ground = false;
    platforms.forEach(p => {
        let dx = Math.abs(player.position.x - p.position.x);
        let dz = Math.abs(player.position.z - p.position.z);
        if (dx < 1.5 && dz < 1.5 && player.position.y > p.position.y && player.position.y < p.position.y + 1.2) {
            player.position.y = p.position.y + 0.9;
            velocity.y = 0;
            ground = true;
            if (p.material.color.getHex() === 0xf1c40f) {
                currentLevel++;
                player.position.set(0, 5, 0);
                buildLevel(currentLevel);
            }
        }
    });

    if (ground && keys['Space']) velocity.y = 0.26;
    if (player.position.y < -15) { player.position.set(0, 5, 0); velocity.y = 0; }

    // –ö–∞–º–µ—Ä–∞ –æ—Ç 3-–≥–æ –ª–∏—Ü–∞ (–≤—Å–µ–≥–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –∫—É–¥–∞ –Ω–∞–¥–æ)
    const relativeCameraOffset = new THREE.Vector3(0, 1.5, 5);
    const cameraOffset = relativeCameraOffset.applyQuaternion(player.quaternion);
    camera.position.copy(player.position).add(cameraOffset);
    
    // –ü–ª–∞–≤–Ω—ã–π –≤–∑–≥–ª—è–¥ –∑–∞ –º—ã—à–∫–æ–π
    const lookTarget = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
    camera.lookAt(lookTarget);
    camera.rotation.x += pitch * 0.5; // –î–æ–±–∞–≤–ª—è–µ–º –Ω–∞–∫–ª–æ–Ω –∫–∞–º–µ—Ä—ã –≤–≤–µ—Ä—Ö-–≤–Ω–∏–∑

    renderer.render(scene, camera);
}

window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>